trigger:
  branches:
    include:
      - main  # Run on every push to main

pool:
  vmImage: 'ubuntu-latest'

# ‚úÖ Enable Debug for Better Error Tracking
variables:
  System.Debug: true
  SIGN_FUNCTION_URL: "https://my-function-app26012004.azurewebsites.net/api/SignAndExport?code=rvAZsWPQvdCVgCnCGKop1ocVwh5okKv9oSNTHhgoth2yAzFul1duiA=="
  VERIFY_FUNCTION_URL: "https://my-function-app26012004.azurewebsites.net/api/VerifySignature?code=mO4i4ujkrXC5aFWF1H1kr95wqe7SxxcG1D7tbZTFwVm6AzFukp4BHQ=="

stages:
  # ‚úÖ Stage 1: Sign and Verify
  - stage: SignAndVerify
    displayName: "Sign and Verify Code"
    jobs:
      - job: SignAndVerifyJob
        displayName: "Sign and Verify Job"
        steps:
          # ‚úÖ Step 1: Checkout Code
          - checkout: self
            fetchDepth: 1
            persistCredentials: true
            displayName: "Checkout Code"

          # ‚úÖ Step 2: Debug Variables
          - script: |
              echo "üîç Checking Variable Values..."
              echo "SIGN_FUNCTION_URL: $(SIGN_FUNCTION_URL)"
              echo "VERIFY_FUNCTION_URL: $(VERIFY_FUNCTION_URL)"
              echo "‚úÖ Variables successfully loaded."
            displayName: "Debug Variables"

          # ‚úÖ Step 3: Zip the Code
          - script: |
              echo "üì¶ Zipping the code..."
              zip -r code_to_sign.zip ./
              echo "‚úÖ Code zipped successfully."
            displayName: "Zip the Code for Signing"

          # ‚úÖ Step 4: Encode Zip File to Base64
          - script: |
              echo "üîê Encoding ZIP to base64..."
              base64 -w 0 code_to_sign.zip > code_to_sign.b64
              echo "‚úÖ Base64 encoding complete."
            displayName: "Encode ZIP File"

          # ‚úÖ Step 5: Invoke Azure Function for Signing (With 3 Files)
          - task: PowerShell@2
            displayName: "Invoke Sign API using PowerShell (Binary Handling)"
            inputs:
              targetType: 'inline'
              script: |
                $url = "$(SIGN_FUNCTION_URL)"
                
                # ‚úÖ Correct file paths
                $filePath = "$(System.DefaultWorkingDirectory)/code_to_sign.zip"
                $privateKeyPath = "$(System.DefaultWorkingDirectory)/private-key.asc"
                $passphrase = "my-secret-passphrase"  # Or use a secure variable
                
                # ‚úÖ Check if files exist
                if (-Not (Test-Path $filePath)) {
                  Write-Error "‚ùå File not found: $filePath"
                  exit 1
                }
                if (-Not (Test-Path $privateKeyPath)) {
                  Write-Error "‚ùå Private key not found: $privateKeyPath"
                  exit 1
                }
          
                # ‚úÖ Create Multipart Form Data
                $boundary = [System.Guid]::NewGuid().ToString()
                $LF = "`r`n"
          
                # üîπ Add File Content
                $fileContent = [System.IO.File]::ReadAllBytes($filePath)
                $fileData = "--$boundary$LF" +
                            "Content-Disposition: form-data; name=`"file`"; filename=`"$(Split-Path -Leaf $filePath)`"$LF" +
                            "Content-Type: application/zip$LF$LF" +
                            [System.Text.Encoding]::Default.GetString($fileContent) + $LF
          
                # üîπ Add Private Key
                $keyContent = [System.IO.File]::ReadAllBytes($privateKeyPath)
                $keyData = "--$boundary$LF" +
                            "Content-Disposition: form-data; name=`"privateKeyFile`"; filename=`"$(Split-Path -Leaf $privateKeyPath)`"$LF" +
                            "Content-Type: application/octet-stream$LF$LF" +
                            [System.Text.Encoding]::Default.GetString($keyContent) + $LF
          
                # üîπ Add Passphrase
                $passphraseData = "--$boundary$LF" +
                                  "Content-Disposition: form-data; name=`"passphrase`"$LF$LF" +
                                  "$passphrase$LF"
          
                # ‚úÖ Combine Form Data
                $body = $fileData + $keyData + $passphraseData + "--$boundary--$LF"
          
                # ‚úÖ Invoke REST API with Binary Handling
                try {
                  Write-Output "‚úçÔ∏è Invoking Azure Function to Sign..."
                  $outputZipPath = "$(System.DefaultWorkingDirectory)/signed_code.zip"
          
                  # üöÄ Invoke API and save response to signed_code.zip
                  Invoke-WebRequest -Uri $url -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body ([System.Text.Encoding]::UTF8.GetBytes($body)) -OutFile $outputZipPath
          
                  # ‚úÖ Check if file is created
                  if (-Not (Test-Path $outputZipPath)) {
                    Write-Error "‚ùå Signed file not received. Check Azure Function logs."
                    exit 1
                  }
          
                  Write-Output "‚úÖ Code signed and saved to signed_code.zip successfully."
          
                } catch {
                  Write-Error "‚ùå Error invoking Sign API: $_"
                  exit 1
                }
          # ‚úÖ Step 8: Publish Signed Artifact
          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/signed_code.zip"
              artifactName: "signed_code"
            displayName: "Publish Signed Code Artifact"


          # ‚úÖ Step 6: Encode Signed File to Base64
          - script: |
              echo "üîê Encoding signed ZIP to base64..."
              base64 -w 0 signed_code.zip > signed_code.b64
              echo "‚úÖ Signed file encoded successfully."
            displayName: "Encode Signed ZIP File"

          # ‚úÖ Step 7: Invoke Azure Function for Verification
          - task: PowerShell@2
            displayName: "Invoke Verify API using PowerShell"
            inputs:
              targetType: 'inline'
              script: |
                $url = "$(VERIFY_FUNCTION_URL)"
                $base64Data = Get-Content -Path "signed_code.b64" -Raw
                $jsonBody = @{
                  task = @{
                    file = $base64Data
                    metadata = "verify_request"
                  }
                } | ConvertTo-Json -Depth 3

                Write-Output "üîé Invoking Azure Function to Verify..."
                try {
                  $response = Invoke-RestMethod -Uri $url -Method Post -Body $jsonBody -ContentType "application/json"
                  Write-Output "üîé Response: $response"
                  
                  # Check verification status
                  if ($response.verificationStatus -ne "true") {
                    Write-Error "‚ùå Signature verification failed."
                    exit 1
                  }

                  Write-Output "‚úÖ Signature verified successfully."

                } catch {
                  Write-Error "‚ùå Error invoking Verify API: $_"
                  exit 1
                }

          # ‚úÖ Step 8: Publish Signed Artifact
          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/signed_code.zip"
              artifactName: "signed_code"
            displayName: "Publish Signed Artifact"

  # ‚úÖ Stage 2: Deploy
  - stage: Deploy
    displayName: "Deploy Signed Code"
    dependsOn: SignAndVerify
    condition: succeeded()
    jobs:
      - job: DeployJob
        displayName: "Deploy Signed Code"
        steps:
          # ‚úÖ Step 9: Download Signed Artifact
          - task: DownloadPipelineArtifact@2
            inputs:
              artifactName: "signed_code"
              targetPath: "$(System.DefaultWorkingDirectory)/signed_code"
            displayName: "Download Signed Artifact"

          # ‚úÖ Step 10: Deploy Signed Artifact to Azure App Service
          - script: |
              echo "üöÄ Deploying signed code to Azure App Service..."
              az webapp deployment source config-zip \
                --resource-group myResourceGroup \
                --name my-web-app \
                --src "$(System.DefaultWorkingDirectory)/signed_code/signed_code.zip"
              echo "‚úÖ Deployment completed successfully."
            displayName: "Deploy to Azure App Service"
