trigger:
  branches:
    include:
      - main  # Run on every push to main

pool:
  vmImage: 'ubuntu-latest'

# ‚úÖ Enable Debug for Better Error Tracking
variables:
  System.Debug: true
  SIGN_FUNCTION_URL: "https://my-function-app26012004.azurewebsites.net/api/SignAndExport?code=rvAZsWPQvdCVgCnCGKop1ocVwh5okKv9oSNTHhgoth2yAzFul1duiA=="
  VERIFY_FUNCTION_URL: "https://my-function-app26012004.azurewebsites.net/api/VerifySignature?code=otiTTgpS5NMhUzTaD6Y7Ij82pWgDTlFNBejznqnMu9lmAzFuGDJgBg=="

stages:
  # ‚úÖ Stage 1: Sign and Verify
  - stage: SignAndVerify
    displayName: "Sign and Verify Code"
    jobs:
      - job: SignAndVerifyJob
        displayName: "Sign and Verify Job"
        steps:
          # ‚úÖ Step 1: Checkout Code
          - checkout: self
            fetchDepth: 1
            persistCredentials: true
            displayName: "Checkout Code"

          # ‚úÖ Step 2: Debug Variables
          - script: |
              echo "üîç Checking Variable Values..."
              echo "SIGN_FUNCTION_URL: $(SIGN_FUNCTION_URL)"
              echo "VERIFY_FUNCTION_URL: $(VERIFY_FUNCTION_URL)"
              echo "‚úÖ Variables successfully loaded."
            displayName: "Debug Variables"

          # # ‚úÖ Step 3: Zip the Code
          # - script: |
          #     echo "üì¶ Zipping the code..."
          #     zip -r code_to_sign.zip ./
          #     echo "‚úÖ Code zipped successfully."
          #   displayName: "Zip the Code for Signing"

          # ‚úÖ Step 4: Invoke Azure Function for Signing (With 3 Files)
          - task: PowerShell@2
            displayName: "Invoke Sign API using PowerShell (Binary Handling)"
            inputs:
              targetType: 'inline'
              script: |
                $url = "$(SIGN_FUNCTION_URL)"
                
                # ‚úÖ Correct file paths
                $filePath = "$(System.DefaultWorkingDirectory)/code_to_sign.zip"
                $privateKeyPath = "$(System.DefaultWorkingDirectory)/private-key.asc"
                $passphrase = "dwee1234@@"  # Or use a secure variable
                
                # ‚úÖ Check if files exist
                if (-Not (Test-Path $filePath)) {
                  Write-Error "‚ùå File not found: $filePath"
                  exit 1
                }
                if (-Not (Test-Path $privateKeyPath)) {
                  Write-Error "‚ùå Private key not found: $privateKeyPath"
                  exit 1
                }
                
                # ‚úÖ Invoke API with files using -InFile (Binary Mode)
                Write-Output "‚úçÔ∏è Invoking Azure Function to Sign..."
                $outputZipPath = "$(System.DefaultWorkingDirectory)/output.zip"
                
                $form = @{
                  file = Get-Item -Path $filePath
                  privateKeyFile = Get-Item -Path $privateKeyPath
                  passphrase = $passphrase
                }
                
                # üöÄ Invoke Sign API with Multipart Form Data
                Invoke-RestMethod -Uri $url -Method Post -Form $form -OutFile $outputZipPath
                
                # ‚úÖ Check if signed file is created
                if (-Not (Test-Path $outputZipPath)) {
                  Write-Error "‚ùå Signed file not received. Check Azure Function logs."
                  exit 1
                }
                
                Write-Output "‚úÖ Code signed and saved to output.zip successfully."

          # ‚úÖ Step 5: Publish Signed Artifact
          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/output.zip"
              artifactName: "output"
            displayName: "Publish Signed Artifact"

          # ‚úÖ Step 8: Open output.zip and Modify ModbusTCPMaster.zip
          - script: |
              echo "üìÇ Unzipping output.zip..."
              unzip -o output.zip -d temp_dir
              echo "‚úÖ Unzip Complete"
          
              echo "üìÇ Unzipping code_to_sign.zip from extracted content..."
              if [ -f "temp_dir/code_to_sign.zip" ]; then
                unzip -o temp_dir/code_to_sign.zip -d temp_dir/code_to_sign
                echo "‚úÖ code_to_sign.zip extracted successfully"
              else
                echo "‚ùå Error: code_to_sign.zip not found!"
                exit 1
              fi
          
              echo "üìù Modifying package_config.json..."
              PACKAGE_CONFIG="temp_dir/code_to_sign/package_config.json"
              
              # Check if the file exists
              if [ -f "$PACKAGE_CONFIG" ]; then
                # Modify the content (Example: Add a new field or update an existing one)
                rm "$PACKAGE_CONFIG"
                echo "‚úÖ package_config.json modified successfully"
              else
                echo "‚ùå Error: package_config.json not found!"
                exit 1
              fi
          
              echo "üì¶ Zipping code_to_sign content again..."
              cd temp_dir/code_to_sign
              zip -r signed_code.zip .
              mv code_to_sign.zip ../
              cd ../..
          
              echo "üì¶ Replacing modified code_to_sign.zip in output.zip..."
              cd temp_dir
              zip -r ../output.zip *
              cd ..
              echo "‚úÖ output.zip updated successfully"
            displayName: "Open, Modify & Re-zip code_to_sign.zip"
          
          # ‚úÖ Step 9: Verify Updated output.zip Existence
          - script: |
              if [ -f "output.zip" ]; then
                echo "‚úÖ Updated output.zip found successfully"
              else
                echo "‚ùå Error: Updated output.zip not found!"
                exit 1
              fi
            displayName: "Verify Updated output.zip"

          # ‚úÖ Step 6: Invoke Azure Function for Verification
          - task: PowerShell@2
            displayName: "Invoke Verify API using PowerShell (Raw Data)"
            inputs:
              targetType: 'inline'
              script: |
                # ‚úÖ Define API URL and File Path
                $url = "$(VERIFY_FUNCTION_URL)"
                $signedCodePath = "$(System.DefaultWorkingDirectory)/output.zip"
                
                # ‚úÖ Check if File Exists
                if (-Not (Test-Path $signedCodePath)) {
                    Write-Error "‚ùå Signed file not found: $signedCodePath"
                    exit 1
                }
                
                # ‚úÖ Prepare HTTP Headers for API Call
                $headers = @{
                    "Content-Type" = "application/octet-stream"  # Use this for raw binary zip
                }
                  
                $form = @{
                  file = Get-Item -Path $signedCodePath
                }
                
                # ‚úÖ Send Raw Binary Data Using Invoke-RestMethod
                try {
                    Write-Output "üîé Invoking Azure Function to Verify with Raw Binary Data..."
                    
                    # üöÄ Sending raw binary zip using -InFile
                    $response = Invoke-RestMethod -Uri $url -Method Post -Form $form
                    
                    # ‚úÖ Check if Verification was Successful
                    Write-Output "üîé Verification Response: $response"
                    
                    if ($response -match "Signature verified successfully") {
                        Write-Output "‚úÖ Verification successful. File is authentic."
                    }
                    else {
                        Write-Error "‚ùå Verification failed! Possible tampering detected."
                        exit 1
                    }
                }
                catch {
                    # ‚úÖ Capture Detailed Error Information
                    Write-Error "‚ùå Error invoking Verify API: $_"
                    exit 1
                }

          # ‚úÖ Step 7: Publish Verified Output (output.zip)
          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/output.zip"
              artifactName: "output_zip"
            displayName: "Publish Verified Output (output.zip)"

  # ‚úÖ Stage 2: Deploy
  - stage: Deploy
    displayName: "Deploy Signed Code"
    dependsOn: SignAndVerify
    condition: succeeded()
    jobs:
      - job: DeployJob
        displayName: "Deploy Signed Code"
        steps:
          # ‚úÖ Step 8: Download Verified Output Artifact
          - task: DownloadPipelineArtifact@2
            inputs:
              artifactName: "output_zip"
              targetPath: "$(System.DefaultWorkingDirectory)/output"
            displayName: "Download Verified Output Artifact"

          # ‚úÖ Step 9: Deploy Verified Output to Azure App Service
          - script: |
              echo "üöÄ Deploying verified output to Azure App Service..."
              az webapp deployment source config-zip \
                --resource-group myResourceGroup \
                --name my-web-app \
                --src "$(System.DefaultWorkingDirectory)/output/output.zip"
              echo "‚úÖ Deployment completed successfully."
            displayName: "Deploy Verified Output"
